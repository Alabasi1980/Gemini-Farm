# تقرير بنية المزامنة وحل التعارض (Sync Architecture & Conflict Resolution Report)

**المشروع:** Gemini Farm
**الحالة:** تم الحل (Resolved)
**الاستراتيجية المعتمدة:** Mutation ID + Session ID Tracking

---

## 1. المشكلة (The Problem)
ظهور رسالة "Sync Conflict" (تعارض في المزامنة) بشكل متكرر وتلقائي عند قيام اللاعب بعمليات سريعة (مثل الحصاد أو البيع)، مما يطلب إعادة تحميل اللعبة، رغم أن اللاعب يستخدم نافذة واحدة وجهازًا واحدًا.

---

## 2. التحليل الجذري (Root Cause Analysis)
المشكلة ناتجة عن **حالة سباق (Race Condition)** بين دورة "الكتابة" ودورة "الاستماع" في Firebase Firestore:

1.  **الإجراء:** يقوم العميل بإرسال تحديث ذري (Atomic Update) لزيادة الذهب.
2.  **الاستجابة السريعة (Latency Compensation):** تقوم Firestore بإرسال Snapshot جديد للعميل يحتوي على البيانات المحدثة ووقت الخادم الجديد (`serverTimestamp`).
3.  **السباق:** تصل هذه الـ Snapshot إلى العميل **قبل** أن تنتهي دالة الحفظ المحلية (`Promise`) من تحديث الطابع الزمني المحلي (`lastLoadedTimestamp`).
4.  **الخطأ:** يقارن العميل وقت الـ Snapshot (الجديد) بوقته المحلي (القديم)، فيستنتج خطأً أن البيانات تغيرت من مصدر خارجي، ويطلق إنذار التعارض.

استخدام "مؤشر منطقي" (Boolean Flag) لحل المشكلة أثبت عدم كفاءته بسبب عدم القدرة على ضمان توقيت وصول الـ Snapshots بدقة.

---

## 3. الحل المنفذ: نمط تتبع الطفرات (Mutation ID Pattern)

بناءً على التوصيات التقنية المتقدمة، قمنا بتنفيذ حل يعتمد على **هوية العملية** بدلاً من توقيتها.

### المكونات:
1.  **Session ID (معرف الجلسة):** `UUID` يتم توليده مرة واحدة عند فتح اللعبة. يميز هذا التبويب عن أي تبويب آخر.
2.  **Mutation ID (معرف الطفرة):** `UUID` يتم توليده لكل عملية كتابة (حفظ أو تحديث موارد).
3.  **Pending Mutations (الطفرات المعلقة):** قائمة محلية تحتفظ بمعرفات العمليات التي أرسلناها ولم نتلقَّ تأكيدها بعد.

### آلية العمل الجديدة:

1.  **عند الحفظ:**
    *   نولد `mutationId`.
    *   نضيفه إلى قائمة `pendingMutations`.
    *   نرسل البيانات للخادم مرفقة بـ `lastMutation: { sessionId, mutationId }`.

2.  **عند الاستماع (onSnapshot):**
    *   نقرأ حقل `lastMutation` من البيانات القادمة.
    *   **الشرط الذكي:** هل `sessionId` القادم يطابق جلستي؟ **و** هل `mutationId` موجود في قائمتي المعلقة؟
    *   **نعم (إنه صدى صوتي):**
        *   هذا التحديث ناتج عن عمليتي أنا.
        *   أقوم بإزالة `mutationId` من القائمة المعلقة.
        *   أحدث توقيتي المحلي (`lastLoadedTimestamp`) بصمت.
        *   **أتجاهل فحص التعارض تماماً.**
    *   **لا (تحديث غريب):**
        *   إذا اختلف الـ `sessionId` أو الـ `mutationId`، فهذا يعني أن جهازًا آخر (أو تبويبًا آخر) قام بالتعديل.
        *   هنا فقط نطبق منطق التعارض ونطلب من اللاعب إعادة التحميل.

---

## 4. الفوائد
*   **دقة 100%:** لا يعتمد الحل على سرعة الشبكة أو توقيت الوعود (Promises).
*   **تجربة مستخدم سلسة:** اختفاء رسائل التعارض الوهمية تماماً.
*   **أمان البيانات:** لا نزال نحمي اللاعب من التعارضات الحقيقية (مثل فتح اللعبة في مكانين)، لأن الـ `Session ID` سيكون مختلفاً.

